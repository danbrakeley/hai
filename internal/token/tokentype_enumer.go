// Code generated by "enumer -type=TokenType -json -transform=snake"; DO NOT EDIT.

package token

import (
	"encoding/json"
	"fmt"
	"strings"
)

const _TokenTypeName = "illegaleofidentintassignplusminusbangasteriskslashltgteqnot_eqcommasemicolonlparenrparenlbracerbracefunctionlettruefalseifelsereturn"

var _TokenTypeIndex = [...]uint8{0, 7, 10, 15, 18, 24, 28, 33, 37, 45, 50, 52, 54, 56, 62, 67, 76, 82, 88, 94, 100, 108, 111, 115, 120, 122, 126, 132}

const _TokenTypeLowerName = "illegaleofidentintassignplusminusbangasteriskslashltgteqnot_eqcommasemicolonlparenrparenlbracerbracefunctionlettruefalseifelsereturn"

func (i TokenType) String() string {
	if i >= TokenType(len(_TokenTypeIndex)-1) {
		return fmt.Sprintf("TokenType(%d)", i)
	}
	return _TokenTypeName[_TokenTypeIndex[i]:_TokenTypeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _TokenTypeNoOp() {
	var x [1]struct{}
	_ = x[ILLEGAL-(0)]
	_ = x[EOF-(1)]
	_ = x[IDENT-(2)]
	_ = x[INT-(3)]
	_ = x[ASSIGN-(4)]
	_ = x[PLUS-(5)]
	_ = x[MINUS-(6)]
	_ = x[BANG-(7)]
	_ = x[ASTERISK-(8)]
	_ = x[SLASH-(9)]
	_ = x[LT-(10)]
	_ = x[GT-(11)]
	_ = x[EQ-(12)]
	_ = x[NOT_EQ-(13)]
	_ = x[COMMA-(14)]
	_ = x[SEMICOLON-(15)]
	_ = x[LPAREN-(16)]
	_ = x[RPAREN-(17)]
	_ = x[LBRACE-(18)]
	_ = x[RBRACE-(19)]
	_ = x[FUNCTION-(20)]
	_ = x[LET-(21)]
	_ = x[TRUE-(22)]
	_ = x[FALSE-(23)]
	_ = x[IF-(24)]
	_ = x[ELSE-(25)]
	_ = x[RETURN-(26)]
}

var _TokenTypeValues = []TokenType{ILLEGAL, EOF, IDENT, INT, ASSIGN, PLUS, MINUS, BANG, ASTERISK, SLASH, LT, GT, EQ, NOT_EQ, COMMA, SEMICOLON, LPAREN, RPAREN, LBRACE, RBRACE, FUNCTION, LET, TRUE, FALSE, IF, ELSE, RETURN}

var _TokenTypeNameToValueMap = map[string]TokenType{
	_TokenTypeName[0:7]:          ILLEGAL,
	_TokenTypeLowerName[0:7]:     ILLEGAL,
	_TokenTypeName[7:10]:         EOF,
	_TokenTypeLowerName[7:10]:    EOF,
	_TokenTypeName[10:15]:        IDENT,
	_TokenTypeLowerName[10:15]:   IDENT,
	_TokenTypeName[15:18]:        INT,
	_TokenTypeLowerName[15:18]:   INT,
	_TokenTypeName[18:24]:        ASSIGN,
	_TokenTypeLowerName[18:24]:   ASSIGN,
	_TokenTypeName[24:28]:        PLUS,
	_TokenTypeLowerName[24:28]:   PLUS,
	_TokenTypeName[28:33]:        MINUS,
	_TokenTypeLowerName[28:33]:   MINUS,
	_TokenTypeName[33:37]:        BANG,
	_TokenTypeLowerName[33:37]:   BANG,
	_TokenTypeName[37:45]:        ASTERISK,
	_TokenTypeLowerName[37:45]:   ASTERISK,
	_TokenTypeName[45:50]:        SLASH,
	_TokenTypeLowerName[45:50]:   SLASH,
	_TokenTypeName[50:52]:        LT,
	_TokenTypeLowerName[50:52]:   LT,
	_TokenTypeName[52:54]:        GT,
	_TokenTypeLowerName[52:54]:   GT,
	_TokenTypeName[54:56]:        EQ,
	_TokenTypeLowerName[54:56]:   EQ,
	_TokenTypeName[56:62]:        NOT_EQ,
	_TokenTypeLowerName[56:62]:   NOT_EQ,
	_TokenTypeName[62:67]:        COMMA,
	_TokenTypeLowerName[62:67]:   COMMA,
	_TokenTypeName[67:76]:        SEMICOLON,
	_TokenTypeLowerName[67:76]:   SEMICOLON,
	_TokenTypeName[76:82]:        LPAREN,
	_TokenTypeLowerName[76:82]:   LPAREN,
	_TokenTypeName[82:88]:        RPAREN,
	_TokenTypeLowerName[82:88]:   RPAREN,
	_TokenTypeName[88:94]:        LBRACE,
	_TokenTypeLowerName[88:94]:   LBRACE,
	_TokenTypeName[94:100]:       RBRACE,
	_TokenTypeLowerName[94:100]:  RBRACE,
	_TokenTypeName[100:108]:      FUNCTION,
	_TokenTypeLowerName[100:108]: FUNCTION,
	_TokenTypeName[108:111]:      LET,
	_TokenTypeLowerName[108:111]: LET,
	_TokenTypeName[111:115]:      TRUE,
	_TokenTypeLowerName[111:115]: TRUE,
	_TokenTypeName[115:120]:      FALSE,
	_TokenTypeLowerName[115:120]: FALSE,
	_TokenTypeName[120:122]:      IF,
	_TokenTypeLowerName[120:122]: IF,
	_TokenTypeName[122:126]:      ELSE,
	_TokenTypeLowerName[122:126]: ELSE,
	_TokenTypeName[126:132]:      RETURN,
	_TokenTypeLowerName[126:132]: RETURN,
}

var _TokenTypeNames = []string{
	_TokenTypeName[0:7],
	_TokenTypeName[7:10],
	_TokenTypeName[10:15],
	_TokenTypeName[15:18],
	_TokenTypeName[18:24],
	_TokenTypeName[24:28],
	_TokenTypeName[28:33],
	_TokenTypeName[33:37],
	_TokenTypeName[37:45],
	_TokenTypeName[45:50],
	_TokenTypeName[50:52],
	_TokenTypeName[52:54],
	_TokenTypeName[54:56],
	_TokenTypeName[56:62],
	_TokenTypeName[62:67],
	_TokenTypeName[67:76],
	_TokenTypeName[76:82],
	_TokenTypeName[82:88],
	_TokenTypeName[88:94],
	_TokenTypeName[94:100],
	_TokenTypeName[100:108],
	_TokenTypeName[108:111],
	_TokenTypeName[111:115],
	_TokenTypeName[115:120],
	_TokenTypeName[120:122],
	_TokenTypeName[122:126],
	_TokenTypeName[126:132],
}

// TokenTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func TokenTypeString(s string) (TokenType, error) {
	if val, ok := _TokenTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _TokenTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to TokenType values", s)
}

// TokenTypeValues returns all values of the enum
func TokenTypeValues() []TokenType {
	return _TokenTypeValues
}

// TokenTypeStrings returns a slice of all String values of the enum
func TokenTypeStrings() []string {
	strs := make([]string, len(_TokenTypeNames))
	copy(strs, _TokenTypeNames)
	return strs
}

// IsATokenType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i TokenType) IsATokenType() bool {
	for _, v := range _TokenTypeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for TokenType
func (i TokenType) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for TokenType
func (i *TokenType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("TokenType should be a string, got %s", data)
	}

	var err error
	*i, err = TokenTypeString(s)
	return err
}
