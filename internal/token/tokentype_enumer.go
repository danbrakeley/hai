// Code generated by "enumer -type=TokenType -json -transform=snake"; DO NOT EDIT.

package token

import (
	"encoding/json"
	"fmt"
	"strings"
)

const _TokenTypeName = "illegaleofidentintassignpluscommasemicolonlparenrparenlbracerbracefunctionlet"

var _TokenTypeIndex = [...]uint8{0, 7, 10, 15, 18, 24, 28, 33, 42, 48, 54, 60, 66, 74, 77}

const _TokenTypeLowerName = "illegaleofidentintassignpluscommasemicolonlparenrparenlbracerbracefunctionlet"

func (i TokenType) String() string {
	if i >= TokenType(len(_TokenTypeIndex)-1) {
		return fmt.Sprintf("TokenType(%d)", i)
	}
	return _TokenTypeName[_TokenTypeIndex[i]:_TokenTypeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _TokenTypeNoOp() {
	var x [1]struct{}
	_ = x[ILLEGAL-(0)]
	_ = x[EOF-(1)]
	_ = x[IDENT-(2)]
	_ = x[INT-(3)]
	_ = x[ASSIGN-(4)]
	_ = x[PLUS-(5)]
	_ = x[COMMA-(6)]
	_ = x[SEMICOLON-(7)]
	_ = x[LPAREN-(8)]
	_ = x[RPAREN-(9)]
	_ = x[LBRACE-(10)]
	_ = x[RBRACE-(11)]
	_ = x[FUNCTION-(12)]
	_ = x[LET-(13)]
}

var _TokenTypeValues = []TokenType{ILLEGAL, EOF, IDENT, INT, ASSIGN, PLUS, COMMA, SEMICOLON, LPAREN, RPAREN, LBRACE, RBRACE, FUNCTION, LET}

var _TokenTypeNameToValueMap = map[string]TokenType{
	_TokenTypeName[0:7]:        ILLEGAL,
	_TokenTypeLowerName[0:7]:   ILLEGAL,
	_TokenTypeName[7:10]:       EOF,
	_TokenTypeLowerName[7:10]:  EOF,
	_TokenTypeName[10:15]:      IDENT,
	_TokenTypeLowerName[10:15]: IDENT,
	_TokenTypeName[15:18]:      INT,
	_TokenTypeLowerName[15:18]: INT,
	_TokenTypeName[18:24]:      ASSIGN,
	_TokenTypeLowerName[18:24]: ASSIGN,
	_TokenTypeName[24:28]:      PLUS,
	_TokenTypeLowerName[24:28]: PLUS,
	_TokenTypeName[28:33]:      COMMA,
	_TokenTypeLowerName[28:33]: COMMA,
	_TokenTypeName[33:42]:      SEMICOLON,
	_TokenTypeLowerName[33:42]: SEMICOLON,
	_TokenTypeName[42:48]:      LPAREN,
	_TokenTypeLowerName[42:48]: LPAREN,
	_TokenTypeName[48:54]:      RPAREN,
	_TokenTypeLowerName[48:54]: RPAREN,
	_TokenTypeName[54:60]:      LBRACE,
	_TokenTypeLowerName[54:60]: LBRACE,
	_TokenTypeName[60:66]:      RBRACE,
	_TokenTypeLowerName[60:66]: RBRACE,
	_TokenTypeName[66:74]:      FUNCTION,
	_TokenTypeLowerName[66:74]: FUNCTION,
	_TokenTypeName[74:77]:      LET,
	_TokenTypeLowerName[74:77]: LET,
}

var _TokenTypeNames = []string{
	_TokenTypeName[0:7],
	_TokenTypeName[7:10],
	_TokenTypeName[10:15],
	_TokenTypeName[15:18],
	_TokenTypeName[18:24],
	_TokenTypeName[24:28],
	_TokenTypeName[28:33],
	_TokenTypeName[33:42],
	_TokenTypeName[42:48],
	_TokenTypeName[48:54],
	_TokenTypeName[54:60],
	_TokenTypeName[60:66],
	_TokenTypeName[66:74],
	_TokenTypeName[74:77],
}

// TokenTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func TokenTypeString(s string) (TokenType, error) {
	if val, ok := _TokenTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _TokenTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to TokenType values", s)
}

// TokenTypeValues returns all values of the enum
func TokenTypeValues() []TokenType {
	return _TokenTypeValues
}

// TokenTypeStrings returns a slice of all String values of the enum
func TokenTypeStrings() []string {
	strs := make([]string, len(_TokenTypeNames))
	copy(strs, _TokenTypeNames)
	return strs
}

// IsATokenType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i TokenType) IsATokenType() bool {
	for _, v := range _TokenTypeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for TokenType
func (i TokenType) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for TokenType
func (i *TokenType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("TokenType should be a string, got %s", data)
	}

	var err error
	*i, err = TokenTypeString(s)
	return err
}
